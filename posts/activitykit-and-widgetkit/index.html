<!doctype html><html lang=en-us><title>ActivityKit & WidgetKit on iOS | Blog by Frank</title><meta charset=utf-8><script async src="https://www.googletagmanager.com/gtag/js?id=G-XZQ6YTCMN7"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XZQ6YTCMN7",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta property="og:type" content="article"><meta property="og:title" content="ActivityKit & WidgetKit on iOS :: Blog by Frank"><meta property="og:description" content="
My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. twitter"><meta property="og:url" content="https://yongfrank.github.io/posts/activitykit-and-widgetkit/"><meta property="og:site_name" content="Blog by Frank"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta name=description content="
My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. twitter"><meta itemprop=description content="
My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. twitter"><meta property="og:description" content="
My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. twitter"><meta name=twitter:description content="
My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. twitter"><meta property="og:url" content="https://yongfrank.github.io/posts/activitykit-and-widgetkit/"><meta property="og:site_name" content="Blog by Frank"><meta property="og:type" content="article"><meta property="article:publisher" content><meta property="og:article:published_time" content="2023-03-13T17:23:10+0800"><meta property="article:published_time" content="2023-03-13T17:23:10+0800"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"ActivityKit \u0026 WidgetKit on iOS","author":{"@type":"Person","name":""},"datePublished":"2023-03-13","description":"","wordCount":1840,"mainEntityOfPage":"True","dateModified":"2023-03-13","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Blog by Frank","logo":{"@type":"imageObject","url":"https://www.example.com/images/brand/favicon.png"}}}</script><meta name=generator content="Hugo 0.111.3"><meta name=description content="Explorations, Reflections, and More on My Blog"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://yongfrank.github.io/css/index.css><link rel=canonical href=https://yongfrank.github.io/posts/activitykit-and-widgetkit/><link rel=alternate type=application/rss+xml href title="Blog by Frank"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#578490><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><header><a href=https://yongfrank.github.io/ class=title>Blog by Frank</a><nav><a href=/about/>About</a></nav></header><article><header><h1>ActivityKit & WidgetKit on iOS</h1><time datetime=2023-03-13T17:23:10+08:00>March 13, 2023</time></header><nav id=TableOfContents><ul><li><a href=#live-activity>Live Activity</a><ul><li><a href=#相关限制>相关限制</a></li><li><a href=#生命周期与约束>生命周期与约束</a></li><li><a href=#设计指南-design-guidance>设计指南 design guidance</a></li><li><a href=#live-activity-sizes>Live Activity Sizes</a></li></ul></li><li><a href=#2-coding-代码实现>2. Coding 代码实现</a></li><li><a href=#widgetkit>WidgetKit</a><ul><li><a href=#相关限制与使小组件保持更新-keeping-a-widget-up-to-date>相关限制与使小组件保持更新 Keeping a widget up to date</a></li><li><a href=#在预算范围内计划重新加载-plan-reloads-within-a-budget>在预算范围内计划重新加载 Plan reloads within a budget</a></li><li><a href=#为可预测的事件生成时间表>为可预测的事件生成时间表</a></li><li><a href=#当时间线改变时通知-widgetkitinform-widgetkit-when-a-timeline-changes>当时间线改变时通知 WidgetKit：Inform WidgetKit when a timeline changes</a></li><li><a href=#显示动态日期display-dynamic-dates>显示动态日期：Display dynamic dates</a></li><li><a href=#后台网络请求完成后更新update-after-background-network-requests-complete>后台网络请求完成后更新：Update after background network requests complete</a></li></ul></li><li><a href=#references>References</a></li></ul></nav><blockquote><p>My apps were featured on the App Store a few times during the year because of lock screen widgets. Check my guide on lock screen widgets if you still don&rsquo;t have them in your app. <a href="https://twitter.com/mecid/status/1645349627951034369?s=12&amp;t=qBx4jrzcBhVR7gAQAZeV2Q">twitter</a></p></blockquote><h2 id=live-activity>Live Activity</h2><h3 id=相关限制>相关限制</h3><ul><li>iOS 16.1 及以上</li><li>更新动态数据大小不能超过 4KB</li><li>只能在应用处于前台时从应用启动 LiveActivity。但是，可以在应用程序在后台运行时从应用程序更新或结束实时活动——例如，使用 <a href=https://developer.apple.com/documentation/backgroundtasks>Background Task</a>。</li></ul><h3 id=生命周期与约束>生命周期与约束</h3><ul><li><a href=https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities>利用 Live Activities 显示实时数据</a></li></ul><p>与 Widget 相比，实时活动使用不同的机制来接收更新。Live Activities 不是使用时间轴机制，而是使用 ActivityKit 从您的应用程序接收更新的数据，并通过 ActivityKit push notifications 远程接收。</p><p>Live Activities use a different mechanism to receive updates compared to widgets. Instead of using a timeline mechanism, Live Activities receive updated data from your app with ActivityKit and remotely with ActivityKit push notifications.</p><p>Live Activity 最多可以运行八小时，除非您的应用程序或其他人终止了它。过了这个8小时的时限，系统自动结束。当实时活动结束时，系统会立即将其从灵动岛中移除。但是，实时活动会保留在锁定屏幕上，直到有人将其删除或在系统将其删除之前再保留最多四个小时。因此，实时活动会在锁定屏幕上保留最多 12 小时。</p><p>A Live Activity can be active for up to eight hours unless your app or a person ends it. After this 8-hour limit, the system automatically ends it. When a Live Activity ends, the system immediately removes it from the Dynamic Island. However, the Live Activity remains on the Lock Screen until a person removes it or for up to four additional hours before the system removes it — whichever comes first. As a result, a Live Activity remains on the Lock Screen for a maximum of twelve hours.</p><p>每个 Live Activity 都在自己的沙盒中运行，并且与 Widget 不同，它无法访问网络或接收位置更新。要更新活动实时活动的动态数据，请在您的应用程序中使用 ActivityKit 框架或允许您的 Live Activity 接收 ActivityKit 推送通知，如<a href=https://developer.apple.com/documentation/activitykit/updating-and-ending-your-live-activity-with-activitykit-push-notifications>使用 ActivityKit 推送通知更新和结束您的实时活动</a>中所述。</p><p>Each Live Activity runs in its own sandbox, and — unlike a widget — it can’t access the network or receive location updates. To update the dynamic data of an active Live Activity, use the ActivityKit framework in your app or allow your Live Activities to receive ActivityKit push notifications as described in Updating and ending your Live Activity with ActivityKit push notifications.</p><p>除了使用 ActivityKit 从您的应用程序更新和结束 Live Activity 之外，还可以使用您从服务器发送到 Apple 推送通知服务 (APNs) 的 ActivityKit 推送通知来更新或结束 Live Activity。要了解有关使用推送通知更新实时活动的更多信息，请参阅使用 ActivityKit 推送通知更新和结束实时活动。</p><p>In addition to updating and ending a Live Activity from your app with ActivityKit, update or end a Live Activity with an ActivityKit push notification that you send from your server to the Apple Push Notification service (APNs). To learn more about using push notifications to update your Live Activities, see Updating and ending your Live Activity with ActivityKit push notifications.</p><blockquote><p><a href=https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities>利用 Live Activities 显示实时数据</a></p><p>ActivityKit 更新和 ActivityKit 推送通知的更新动态数据大小不能超过 4KB。The updated dynamic data for both ActivityKit updates and ActivityKit push notifications can’t exceed 4KB in size.</p></blockquote><p>描述实时活动用户界面的代码是应用程序小部件扩展的一部分。尽管实时活动利用了 WidgetKit 的功能，但它们并不是小部件。与用于更新小部件用户界面的时间轴机制相比，您可以使用 ActivityKit 或 ActivityKit Push Notifications 从您的应用程序更新 Live Activity。</p><p>The code that describes the user interface of your Live Activity is part of your app’s widget extension. However, although Live Activities leverage WidgetKit’s functionality, they aren’t widgets. In contrast to the timeline mechanism you use to update your widgets’ user interface, you update a Live Activity from your app with ActivityKit or with ActivityKit push notifications.</p><h3 id=设计指南-design-guidance>设计指南 design guidance</h3><ul><li><a href=https://developer.apple.com/design/human-interface-guidelines/components/system-experiences/live-activities>Live Activities Design Guidance</a></li><li><a href=https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities>Live Activity 在锁屏以及灵动岛的尺寸</a></li></ul><h3 id=live-activity-sizes>Live Activity Sizes</h3><p><img src=https://developer.apple.com/design/human-interface-guidelines/components/system-experiences/live-activities/images/type-minimal_2x.png alt="Minimal(Attatched / Detached)"></p><p><img src=https://developer.apple.com/design/human-interface-guidelines/components/system-experiences/live-activities/images/type-compact_2x.png alt=Compact></p><p><img src=https://docs-assets.developer.apple.com/published/dec913bb4b4e8771fc8e55dbd4bdfb41/expanded-layout@2x.png alt=Expanded></p><p><img src=https://developer.apple.com/design/human-interface-guidelines/components/system-experiences/live-activities/images/live-activity-notch_2x.png alt="Lock Screen"></p><p><img src=https://www.macobserver.com/wp-content/uploads/2022/12/Live-Activities-Update-Frequency.jpg alt="Lock Screen Example"></p><p><img src="https://images.macrumors.com/t/gb6rFHGiyg7gQsCb3yXJDtaPj1A=/1600x0/article-new/2022/09/iOS-16-Live-Activities-Sports-MLB.jpeg" alt="How to Enable More Frequent Updates for Live Activities on iPhone"></p><table><thead><tr><th>Screen dimensions (portrait)</th><th>Compact leading</th><th>Compact trailing</th><th>Minimal (width given as a range)</th><th>Expanded (height given as a range)</th><th>Lock Screen</th></tr></thead><tbody><tr><td>430x932</td><td>62.33x36.67</td><td>62.33x36.67</td><td>36.67–45x36.67</td><td>408x84–160</td><td>408x84–160</td></tr><tr><td>393x852</td><td>52.33x36.67</td><td>52.33x36.67</td><td>36.67–45x36.67</td><td>371x84–160</td><td>371x84–160</td></tr></tbody></table><blockquote><p>如果 Live Activity 的高度超过 160 points，系统可能会在锁屏上截断它。The system may truncate a Live Activity on the Lock Screen if its height exceeds 160 points.</p><p>如果 Live Activity 的高度超过 160 points，系统可能会在灵动岛上截断它。The system may truncate a Live Activity in the Dynamic Island if its height exceeds 160 points.</p></blockquote><h2 id=2-coding-代码实现>2. Coding 代码实现</h2><ol><li>【创建 Extension】Create a widget extension Target(check &ldquo;including Live Activity&rdquo;)</li><li>【权限设置】Info.plist - Supports Live Activities - YES</li><li>【数据结构】Add code that defines an <a href=https://developer.apple.com/documentation/widgetkit/activityattributes>ActivityAttributes</a> structure to describe the static and dynamic data of your Live Activity.</li><li>【灵动岛，锁屏 UI】Use the ActivityAttributes you defined to create the <a href=https://developer.apple.com/documentation/WidgetKit/ActivityConfiguration>ActivityConfiguration</a>.</li><li>Add code to configure, start, update, and end your Live Activities.</li><li>【Update Data】update your Live Activity using the <a href=https://developer.apple.com/documentation/activitykit/activity/update(_:alertconfiguration:)>update(_:alertConfiguration:)</a> function and include an <a href=https://developer.apple.com/documentation/activitykit/alertconfiguration>AlertConfiguration</a>.</li><li>Create a deep link into your app <a href=https://developer.apple.com/documentation/activitykit/activity/widgeturl(_:)>widgetURL(_:)</a></li><li><a href=https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities#Configure-the-Live-Activity>Configure the Live Activity</a></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Define a set of static and dynamic data</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderAttributes</span>: ActivityAttributes {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ContentState</span>: Codable, Hashable {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> status: Status = .unstarted
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> orderNumber: Int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Add Live Activities to the widget extension</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderStatusLiveActivity</span>: Widget {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some WidgetConfiguration {
</span></span><span style=display:flex><span>        ActivityConfiguration(<span style=color:#66d9ef>for</span>: OrderAttributes.<span style=color:#66d9ef>self</span>) { context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Create the presentation that appears on the Lock Screen and as a</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// banner on the Home Screen of devices that don&#39;t support the</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Dynamic Island.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>            OrderStatusLiveActivityView(context: context)
</span></span><span style=display:flex><span>        } dynamicIsland: { context <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Create the presentations that appear in the Dynamic Island.</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>            DynamicIslandView(context: context)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderLockerScreen_Previews</span>: PreviewProvider {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> attributes = OrderAttributes(orderNumber: <span style=color:#ae81ff>24155</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>let</span> contentState = OrderAttributes.ContentState(status: .cycling)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>var</span> previews: some View {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        attributes
</span></span><span style=display:flex><span>            .previewContext(contentState, viewKind: .content)
</span></span><span style=display:flex><span>            .previewDisplayName(<span style=color:#e6db74>&#34;Notification&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If your app already offers widgets, add the Live Activity to your WidgetBundle.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>WidgetKit</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>SwiftUI</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@main
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderStatusBundle</span>: WidgetBundle {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some Widget {
</span></span><span style=display:flex><span>        OrderLockerScreen()
</span></span><span style=display:flex><span>        OrderStatus()
</span></span><span style=display:flex><span>        OrderStatusLiveActivity()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=widgetkit>WidgetKit</h2><ul><li><a href=https://youtu.be/jucm6e9M6LA>How to Build a Widget in Swift with WidgetKit</a></li><li><a href=https://zenn.dev/naoya_maeda/articles/e5c5af8ec567c9>【iOS】WidgetKit Intro</a></li><li><a href=https://developer.apple.com/documentation/widgetkit>WidgetKit</a></li><li><a href=https://kavsoft.dev/swiftui_2.0_widgets>SwiftUI WidgetKit Tutorials - Creating Widget And Displaying Data Parsed From JSON API - SwiftUI</a></li><li><a href=https://developer.apple.com/forums/thread/657518>WidgetKit 刷新策略</a></li></ul><h3 id=相关限制与使小组件保持更新-keeping-a-widget-up-to-date>相关限制与使小组件保持更新 Keeping a widget up to date</h3><blockquote><p><a href=https://developer.apple.com/documentation/widgetkit>WidgetKit Apple Developer</a></p><p>WidgetKit 会尝试遵守指定的日期。</p><p>WidgetKit tries to respect the date you specify</p></blockquote><blockquote><p><a href=https://help.whatsmyeta.co/article/43-how-often-to-home-screen-widgets-update>主屏幕小组件的更新频率 How often to Home Screen widgets update</a></p><p>在我的个人测试中，更新时间可以长达 4-5 小时，短则只有 15 分钟。这像是黑匣子，我们会告诉 iOS 何时更新，但最终取决于您的手机。</p><p>In my own personal testing I&rsquo;ve seen it go out to 4-5 hours, and sometimes it&rsquo;s a short as 15 minutes. These are a bit of a black box as we tell iOS when to update but it&rsquo;s ultimately up to your phone as to when it will.</p></blockquote><ul><li><a href=https://swiftsenpai.com/development/refreshing-widget/>Refreshing Widget Effectively</a></li><li>时间线的影响因素</li></ul><p>WidgetKit 将尽力遵守时间线条目中给出的刷新日期。因此，请注意并避免在特定时间重新加载您的小部件，因为当多个设备尝试同时重新加载时，它可能会阻塞您的远程服务器。</p><p>我们不能使用 AsyncImage 加载图像，因为小部件仅支持同步任务。不能执行异步任务。</p><p>WidgetKit 在一个单独的进程中代表您呈现视图。因此，即使小部件在屏幕上，您的小部件扩展也不会一直处于活动状态。尽管您的小部件并不总是处于活动状态，但您可以通过多种方式使其内容保持最新。</p><p>WidgetKit renders the views on your behalf in a separate process. As a result, your widget extension is not continually active, even if the widget is onscreen. Despite your widget not always being active, there are several ways you can keep its content up to date.</p><ul><li>在预算范围内计划重新加载 Plan reloads within a budget<ul><li>对于用户经常查看的小部件，每日预算通常包括 40 到 70 次刷新。此速率大致相当于每 15 到 60 分钟重新加载一次小部件，但由于所涉及的许多因素，这些间隔通常会有所不同。Widget 小组件对用户可见的频率和时间。Widget 小组件的上次重新加载时间。Widget 小组件的包含应用程序是否处于活动状态。</li></ul></li><li>为可预测的事件生成时间表 Generate a timeline for predictable events<ul><li>WidgetKit 在重新加载小部件之前强加了最短时间。您的时间线提供商应创建至少相隔约 5 分钟的时间线条目。许多小部件都有可预测的时间点，在这些时间点更新它们的内容是有意义的。例如，显示天气信息的小部件可能会全天每小时更新一次温度。股票市场小部件可以在开市时间频繁更新其内容，但在周末根本不更新。通过提前计划这些时间，WidgetKit 会在适当的时间到来时自动刷新您的小部件。</li></ul></li><li>当时间线改变时通知 WidgetKit：Inform WidgetKit when a timeline changes<ul><li>当某些事情影响了小部件的当前时间线时，您的应用程序可以告诉 WidgetKit 请求新的时间线。</li></ul></li><li>显示动态日期：Display dynamic dates<ul><li>即使您的小部件不会持续运行，它也可以显示 WidgetKit 实时更新的基于时间的信息。例如，它可能会显示一个倒计时计时器，即使您的小部件扩展未运行，它也会继续倒计时。</li></ul></li><li>后台网络请求完成后更新：Update after background network requests complete<ul><li>当您的小部件扩展处于活动状态时，例如提供snapshot或时timeline，它可以启动后台网络请求。例如，获取队友当前状态的游戏小部件，或获取带有图像缩略图的标题的新闻小部件。发出异步后台网络请求可让您快速将控制权返回给系统，从而降低因响应时间过长而被终止的风险。</li></ul></li></ul><p><img src=https://storage.googleapis.com/zenn-user-upload/4646e6df778f-20221003.png alt=Widget>
<img src=https://storage.googleapis.com/zenn-user-upload/2813fb5e2f9f-20221003.jpg alt="Lock Screen accessoryCircular, accessoryRectangle, accessoryInline">
<img src=https://storage.googleapis.com/zenn-user-upload/93a97df084d4-20221005.png alt=应用程序识别在小部件中点击的链接>
<img src=https://storage.googleapis.com/zenn-user-upload/18a17e216337-20221001.gif alt="Lock Screen Widget"></p><h3 id=在预算范围内计划重新加载-plan-reloads-within-a-budget>在预算范围内计划重新加载 Plan reloads within a budget</h3><p>由于额外的网络和处理，重新加载小部件会消耗系统资源并导致电池耗尽。要减少这种性能影响并保持全天的电池寿命，请将您请求的更新频率和数量限制在必要的范围内。</p><p>Reloading widgets consumes system resources and causes battery drain due to additional networking and processing. To reduce this performance impact and maintain all-day battery life, limit the frequency and number of updates you request to what’s necessary.</p><p>为了管理系统负载，WidgetKit 使用预算来分配一天中的小部件重新加载。预算分配是动态的，考虑了许多因素，包括：</p><p>To manage system load, WidgetKit uses a budget to distribute widget reloads over the course of the day. The budget allocation is dynamic and takes many factors into account, including:</p><ul><li>小部件对用户可见的频率和时间。The frequency and times the widget is visible to the user.</li><li>小部件的上次重新加载时间。The widget’s last reload time.</li><li>小部件的包含应用程序是否处于活动状态。Whether the widget’s containing app is active.</li></ul><p>WidgetKit 为用户添加到其设备的每个活动小部件维护不同的预算。例如，如果用户添加两个可配置体育小部件实例，显示两个不同球队的信息，则每个小部件都有自己的预算。</p><blockquote><p>小部件的预算适用于 24 小时的时间段。WidgetKit 将 24 小时窗口调整为用户的日常使用模式，这意味着每日预算不一定会在午夜准确重置。对于用户经常查看的小部件，每日预算通常包括 40 到 70 次刷新。此速率大致相当于每 15 到 60 分钟重新加载一次小部件，但由于所涉及的许多因素，这些间隔通常会有所不同。</p></blockquote><p>系统需要几天时间来了解用户的行为。在此学习期间，您的小部件可能会收到比平时更多的重新加载。</p><p>许多小部件都有可预测的时间点，在这些时间点更新它们的内容是有意义的。例如，显示天气信息的小部件可能会全天每小时更新一次温度。股票市场小部件可以在开市时间频繁更新其内容，但在周末根本不更新。通过提前计划这些时间，WidgetKit 会在适当的时间到来时自动刷新您的小部件。</p><h3 id=为可预测的事件生成时间表>为可预测的事件生成时间表</h3><p>如果您的小部件可以预测它应该重新加载的时间点，最好的方法是为尽可能多的未来日期生成时间线。对于您显示的内容，使时间轴中条目的间隔尽可能大。WidgetKit 在重新加载小部件之前强加了最短时间。您的时间线提供商应创建至少相隔约 5 分钟的时间线条目。WidgetKit 可能会跨多个小部件合并重新加载，从而影响重新加载小部件的确切时间。</p><p>If your widget can predict points in time that it should reload, the best approach is to generate a timeline for as many future dates as possible. Keep the interval of entries in the timeline as large as possible for the content you display. WidgetKit imposes a minimum amount of time before it reloads a widget. Your timeline provider should create timeline entries that are at least about 5 minutes apart. WidgetKit may coalesce reloads across multiple widgets, affecting the exact time a widget is reloaded.</p><p>许多小部件都有可预测的时间点，在这些时间点更新它们的内容是有意义的。例如，显示天气信息的小部件可能会全天每小时更新一次温度。股票市场小部件可以在开市时间频繁更新其内容，但在周末根本不更新。通过提前计划这些时间，WidgetKit 会在适当的时间到来时自动刷新您的小部件。</p><h3 id=当时间线改变时通知-widgetkitinform-widgetkit-when-a-timeline-changes>当时间线改变时通知 WidgetKit：Inform WidgetKit when a timeline changes</h3><p>当某些事情影响了小部件的当前时间线时，您的应用程序可以告诉 WidgetKit 请求新的时间线。</p><p>Your app can tell WidgetKit to request a new timeline when something affects a widget’s current timeline.</p><h3 id=显示动态日期display-dynamic-dates>显示动态日期：Display dynamic dates</h3><p>即使您的小部件不会持续运行，它也可以显示 WidgetKit 实时更新的基于时间的信息。例如，它可能会显示一个倒计时计时器，即使您的小部件扩展未运行，它也会继续倒计时。</p><h3 id=后台网络请求完成后更新update-after-background-network-requests-complete>后台网络请求完成后更新：Update after background network requests complete</h3><p>当您的小部件扩展处于活动状态时，例如提供snapshot或时timeline，它可以启动后台网络请求。</p><p>When your widget extension is active, like when providing a snapshot or timeline, it can initiate background network requests.</p><p>例如，获取队友当前状态的游戏小部件，或获取带有图像缩略图的标题的新闻小部件。发出异步后台网络请求可让您快速将控制权返回给系统，从而降低因响应时间过长而被终止的风险。</p><p>For example, a game widget that fetches your teammate’s current status, or a news widget that fetches headlines with image thumbnails. Making asynchronous background network requests let you return control to the system quickly, reducing the risk of being terminated for taking too long to respond.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>WidgetKit</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>SwiftUI</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>Intents</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// TimelineProvider传递一个类型的对象，</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 该对象定义了一个方法来通知 WidgetKit 何时更新小部件，</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 以及一个方法来在每个时间将一个称为时间线条目的对象传递给 WidgetKit。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Provider</span>: IntentTimelineProvider {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// WidgetKit 在显示占位符视图时调用的方法。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TimelineEntry 将对象传递给占位符 View。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当设备的环境发生变化时，例如当设备的动态类型设置发生变化时，</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将显示占位符视图。占位符视图（如下图）用于小部件的外观，没有任何实际内容或数据可显示。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>placeholder</span>(<span style=color:#66d9ef>in</span> context: Context) -&gt; SimpleEntry {
</span></span><span style=display:flex><span>        SimpleEntry(date: Date(), configuration: ConfigurationIntent())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当小部件首次出现在小部件库中时由 WidgetKit 调用的方法。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在完成参数中传递一个对象 TimelineEntry，以向 WidgetKit 提供小部件的 SwiftUI 视图。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getSnapshot</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> configuration: ConfigurationIntent,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span> context: Context,
</span></span><span style=display:flex><span>        completion: @escaping (SimpleEntry) -&gt; ()
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> entry = SimpleEntry(date: Date(), configuration: configuration)
</span></span><span style=display:flex><span>        completion(entry)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从小部件库中选择小部件时由 WidgetKit 调用的方法。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建一个对象，该对象是一组 TimelineEntry 对象数组和一个表示更新下一个时间线的时间的对象。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 然后将生成的对象作为参数传递，以通知 WidgetKit 小部件更新时间。 </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getTimeline</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> configuration: ConfigurationIntent,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>in</span> context: Context,
</span></span><span style=display:flex><span>        completion: @escaping (Timeline&lt;Entry&gt;) -&gt; ()
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> entries: [SimpleEntry] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Generate a timeline consisting of five entries an hour apart, starting from the current date.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> currentDate = Date()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> hourOffset <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span> ..<span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)<span style=color:#f92672>!</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> entry = SimpleEntry(date: entryDate, configuration: configuration)
</span></span><span style=display:flex><span>            entries.append(entry)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> timeline = Timeline(entries: entries, policy: .atEnd)
</span></span><span style=display:flex><span>        completion(timeline)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 时间条目，有关于更新 Widget 的频率</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在示例源代码中，尾随闭包省略了外部参数名称，</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 但 TimelineEntry 传递了一个采用一种类型的对象并返回</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// SwiftUI 视图的闭包。这个返回的 SwiftUI 视图 View 将显示在 Widget 中。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SimpleEntry</span>: TimelineEntry {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> date: Date
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> configuration: ConfigurationIntent
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// SwiftUI View on Widget</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderStatusEntryView</span> : View {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> entry: Provider.Entry
</span></span><span style=display:flex><span>    @Environment(<span style=color:#960050;background-color:#1e0010>\</span>.widgetFamily) <span style=color:#66d9ef>var</span> family
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        ZStack {
</span></span><span style=display:flex><span><span style=color:#75715e>//            BackgroundBlueColor()</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> family == .systemSmall <span style=color:#f92672>||</span> family == .systemLarge <span style=color:#f92672>||</span> family == .systemMedium {
</span></span><span style=display:flex><span>                ContainerRelativeShape()
</span></span><span style=display:flex><span>                    .fill(.gray.gradient)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            VStack {
</span></span><span style=display:flex><span>                Text(entry.date, style: .time)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> family <span style=color:#f92672>!=</span> .accessoryCircular {
</span></span><span style=display:flex><span>                    Text(<span style=color:#e6db74>&#34;hello bike&#34;</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Text(<span style=color:#e6db74>&#34;HB&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SampleWidget2</span>: Widget {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some WidgetConfiguration {
</span></span><span style=display:flex><span>        IntentConfiguration(kind: <span style=color:#e6db74>&#34;others&#34;</span>, intent: ConfigurationIntent.<span style=color:#66d9ef>self</span>, provider: Provider()) { entry <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                SampleWidgetEntryView()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Widget协议定义WidgetConfiguration类型的属性。body</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderStatus</span>: Widget {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Kind Parameter</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// WidgetKit 允许您为一个 Widget Extension 创建多个 widget。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这样做时，kind它充当区分每个小部件的标识符。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 例如，当点击一个小部件启动一个应用程序时，应用程序kind可以识别它是通过哪种类型的小部件启动的。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> kind: String = <span style=color:#e6db74>&#34;OrderStatus&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 小部件设置Configuration定义了小部件范围的设置，例如小部件的类型和支持的小部件的大小，如下所述。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当用户不需要自定义小部件时使用。</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 例如，Photos 应用程序的 widget 仅显示用户存储在 Photos</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 应用程序中的照片，并且不允许用户自定义 widget。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some WidgetConfiguration {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// StaticConfiguration body 对 propertiesWidgetConfiguration 使用以下两个符合协议的属性之一：</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// IntentConfiguration 意图配置</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 用于允许用户自定义小部件。</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 例如，Weather App 小部件允许用户自定义显示天气的区域。</span>
</span></span><span style=display:flex><span>        IntentConfiguration(
</span></span><span style=display:flex><span>            kind: kind,
</span></span><span style=display:flex><span>            intent: ConfigurationIntent.<span style=color:#66d9ef>self</span>,
</span></span><span style=display:flex><span>            provider: Provider()
</span></span><span style=display:flex><span>        ) { entry <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            OrderStatusEntryView(entry: entry)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定在用户配置小部件时显示的描述性文本。</span>
</span></span><span style=display:flex><span>        .configurationDisplayName(<span style=color:#e6db74>&#34;LiveActivity Test&#34;</span>)
</span></span><span style=display:flex><span>        .description(<span style=color:#e6db74>&#34;This is an example widget.&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 指定小部件支持的大小。</span>
</span></span><span style=display:flex><span>        .supportedFamilies(<span style=color:#66d9ef>self</span>.supportFamilies)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> supportFamilies: [WidgetFamily] {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#75715e>#available</span>(<span style=color:#75715e>iOSApplicationExtension</span> <span style=color:#ae81ff>16.0</span>, <span style=color:#f92672>*</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [
</span></span><span style=display:flex><span>                .systemSmall,
</span></span><span style=display:flex><span>                .systemMedium,
</span></span><span style=display:flex><span>                .systemLarge,
</span></span><span style=display:flex><span>                .systemExtraLarge,
</span></span><span style=display:flex><span>                .accessoryInline,
</span></span><span style=display:flex><span>                .accessoryCircular,
</span></span><span style=display:flex><span>                .accessoryRectangular
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [
</span></span><span style=display:flex><span>                .systemSmall,
</span></span><span style=display:flex><span>                .systemMedium,
</span></span><span style=display:flex><span>                .systemLarge
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SampleWidgetEntryView</span> : View {
</span></span><span style=display:flex><span>    @Environment(<span style=color:#960050;background-color:#1e0010>\</span>.widgetFamily) <span style=color:#66d9ef>var</span> family
</span></span><span style=display:flex><span><span style=color:#75715e>//    var entry: Provider.Entry</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        VStack() {
</span></span><span style=display:flex><span>            Link(destination: URL(string: <span style=color:#e6db74>&#34;https://baidu.com&#34;</span>)<span style=color:#f92672>!</span>, label: {
</span></span><span style=display:flex><span>                Text(<span style=color:#e6db74>&#34;Top Link&#34;</span>)
</span></span><span style=display:flex><span>                    .padding()
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            Link(destination: URL(string: <span style=color:#e6db74>&#34;https://apple.com&#34;</span>)<span style=color:#f92672>!</span>, label: {
</span></span><span style=display:flex><span>                Text(<span style=color:#e6db74>&#34;Middle Link&#34;</span>)
</span></span><span style=display:flex><span>                    .padding()
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            Link(destination: URL(string: <span style=color:#e6db74>&#34;https://google.com&#34;</span>)<span style=color:#f92672>!</span>, label: {
</span></span><span style=display:flex><span>                Text(<span style=color:#e6db74>&#34;Bottom Link&#34;</span>)
</span></span><span style=display:flex><span>                    .padding()
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>OrderStatus_Previews</span>: PreviewProvider {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>var</span> previews: some View {
</span></span><span style=display:flex><span>        OrderStatusEntryView(
</span></span><span style=display:flex><span>            entry: SimpleEntry(
</span></span><span style=display:flex><span>                date: Date(),
</span></span><span style=display:flex><span>                configuration: ConfigurationIntent()
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .previewContext(
</span></span><span style=display:flex><span>            WidgetPreviewContext(family: .systemSmall)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        OrderStatusEntryView(
</span></span><span style=display:flex><span>            entry: SimpleEntry(
</span></span><span style=display:flex><span>                date: Date(),
</span></span><span style=display:flex><span>                configuration: ConfigurationIntent()
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .previewContext(
</span></span><span style=display:flex><span>            WidgetPreviewContext(family: .accessoryRectangular)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        OrderStatusEntryView(
</span></span><span style=display:flex><span>            entry: SimpleEntry(
</span></span><span style=display:flex><span>                date: Date(),
</span></span><span style=display:flex><span>                configuration: ConfigurationIntent()
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .previewContext(
</span></span><span style=display:flex><span>            WidgetPreviewContext(family: .accessoryCircular)
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        SampleWidgetEntryView()
</span></span><span style=display:flex><span>            .previewContext(
</span></span><span style=display:flex><span>                WidgetPreviewContext(family: .systemLarge)
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=references>References</h2><ul><li><a href=https://developer.apple.com/documentation/widgetkit/adding_widgets_to_the_lock_screen_and_watch_faces>Adding widgets to the Lock Screen and watch faces</a></li><li><a href=https://www.macobserver.com/tips/quick-tip/how-to-customize-live-activities-update-frequency/>How to Customize Live Activities Update Frequency</a></li><li><a href=https://developer.apple.com/documentation/activitykit/displaying-live-data-with-live-activities#Update-the-Live-Activity>Live Activity</a></li></ul></article></html>