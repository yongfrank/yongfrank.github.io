<!doctype html><html lang=en-us><title>iOS Memory Mamagement | Blog by Frank</title><meta charset=utf-8><script async src="https://www.googletagmanager.com/gtag/js?id=G-XZQ6YTCMN7"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XZQ6YTCMN7",{anonymize_ip:!1})}</script><meta name=description content="<h2 id=&#34;ios-memory-mgmt--arc&#34;>iOS Memory Mgmt / ARC</h2>
<blockquote>
<p><a href=&#34;https://juejin.cn/post/7078882545403854861&#34;>iOS-[内存管理]</a>"><meta itemprop=description content="<h2 id=&#34;ios-memory-mgmt--arc&#34;>iOS Memory Mgmt / ARC</h2>
<blockquote>
<p><a href=&#34;https://juejin.cn/post/7078882545403854861&#34;>iOS-[内存管理]</a>"><meta property="og:description" content="<h2 id=&#34;ios-memory-mgmt--arc&#34;>iOS Memory Mgmt / ARC</h2>
<blockquote>
<p><a href=&#34;https://juejin.cn/post/7078882545403854861&#34;>iOS-[内存管理]</a>"><meta name=twitter:description content="<h2 id=&#34;ios-memory-mgmt--arc&#34;>iOS Memory Mgmt / ARC</h2>
<blockquote>
<p><a href=&#34;https://juejin.cn/post/7078882545403854861&#34;>iOS-[内存管理]</a>"><meta property="og:type" content="article"><meta property="article:publisher" content><meta property="og:article:published_time" content="2023-04-08T23:29:01+0800"><meta property="article:published_time" content="2023-04-08T23:29:01+0800"><script defer type=application/ld+json>{"@context":"http://schema.org","@type":"Article","headline":"iOS Memory Mamagement","author":{"@type":"Person","name":""},"datePublished":"2023-04-08","description":"","wordCount":301,"mainEntityOfPage":"True","dateModified":"2023-04-08","image":{"@type":"imageObject","url":""},"publisher":{"@type":"Organization","name":"Blog by Frank","logo":{"@type":"imageObject","url":"https://www.example.com/images/brand/favicon.png"}}}</script><meta name=generator content="Hugo 0.111.3"><meta name=description content="Explorations, Reflections, and More on My Blog"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://yongfrank.github.io/css/index.css><link rel=canonical href=https://yongfrank.github.io/posts/ios-memory-mamagement/><link rel=alternate type=application/rss+xml href title="Blog by Frank"><header><a href=https://yongfrank.github.io/ class=title>Blog by Frank</a><nav><a href=/about/>About</a></nav></header><article><header><h1>iOS Memory Mamagement</h1><time datetime=2023-04-08T23:29:01+08:00>April 08, 2023</time></header><nav id=TableOfContents><ul><li><a href=#ios-memory-mgmt--arc>iOS Memory Mgmt / ARC</a></li><li><a href=#使用弱引用来避免-retain-cycles>使用弱引用来避免 Retain Cycles</a></li><li><a href=#arc新规则>ARC新规则</a></li><li><a href=#swift>Swift</a><ul><li><a href=#1-arc>1. ARC</a></li><li><a href=#2-strong>2. strong</a></li><li><a href=#3-解决循环引用>3. 解决循环引用</a></li></ul></li></ul></nav><h2 id=ios-memory-mgmt--arc>iOS Memory Mgmt / ARC</h2><blockquote><p><a href=https://juejin.cn/post/7078882545403854861>iOS-[内存管理]</a></p></blockquote><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a17346d91a24355b207b7f5e4785bf8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp alt="ARC 抽象原理图"></p><p>在 Objective-C 中，“对象” 相当于办公室里的照明设备。在现实世界中办公室里的照明设备只有一个，但在 Objective-C 的世界里，虽然计算机的资源有限，但一台计算机可以同时处理好几个对象。</p><p>此外，“对象的使用环境” 相当于上班进入办公室的人。虽然这里的 “环境” 有时也指在运行中的程序代码、变量、变量作用域、对象等，但在概念上就是使用对象的环境。上班进入办公室的人对办公室照明设备发出的动作，与 Objective-C 中的对应关系则如下表所示</p><p><img src=https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b953465c8b994c55b7f5e2be017b224a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp alt="图表 objc memory mgmt"></p><h2 id=使用弱引用来避免-retain-cycles>使用弱引用来避免 Retain Cycles</h2><p>retain对象会创建对该对象的强引用（即引用计数 +1）。一个对象在release它的所有强引用之后（即引用计数 =0）才会dealloc。如果两个对象相互retain强引用，或者多个对象，每个对象都强引用下一个对象直到回到第一个，就会出现 “Retain Cycles（循环引用）” 问题。循环引用会导致它们中的任何对象都无法dealloc，就产生了内存泄漏。</p><p>举个例子，Document 对象中有一个属性 Page 对象，每个 Page 对象都有一个属性，用于存储它所在的 Document。如果 Document 对象具有对 Page 对象的强引用，并且 Page 对象具有对 Document 对象的强引用，则它们都不能被销毁。</p><p>“Retain Cycles” 问题的解决方案是使用弱引用。弱引用是非持有关系，对象do not retain它引用的对象。</p><h2 id=arc新规则>ARC新规则</h2><p>ARC会分析对象的生存期需求，并在编译时自动插入适当的内存管理方法调用的代码，而不需要你记住何时使用retain、release、autorelease方法。编译器还会为你生成合适的dealloc方法。一般来说，如果你使用ARC，那么只有在需要与使用MRC的代码进行交互操作时，传统的 Cocoa 命名约定才显得重要。</p><p>ARC引入了一些在使用其他编译器模式时不存在的新规则。这些规则旨在提供完全可靠的内存管理模型。有时候，它们直接地带来了最好的实践体验，也有时候它们简化了代码，甚至在你丝毫没有关注内存管理问题的时候帮你解决了问题。在ARC下必须遵守以下规则，如果违反这些规则，就会编译错误。</p><ul><li>不能使用 retain / release / retainCount / autorelease</li><li>不能使用 NSAllocateObject / NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不能显式调用 dealloc</li><li>使用 @autoreleasepool 块替代 NSAutoreleasePool</li><li>不能使用区域（NSZone）</li><li>对象型变量不能作为 C 语言结构体（struct / union）的成员</li><li>显式转换 “id” 和 “void *” —— 桥接</li></ul><p>代码示例中，我们创建了一个 ViewController 类，并使用 ARC 管理内存。我们在 ViewController 中创建了一个 UIView 对象，并将其存储在强引用变量中，以便我们可以访问和使用它。我们还创建了一个方法 createSubview，在其中创建了另一个 UIView 对象，并将其存储在弱引用变量中。在方法结束时，该对象将被释放，因为没有强引用变量引用它。</p><p>在 ViewController 中，我们还声明了一个属性 message，它使用 strong 修饰符进行声明。这意味着我们在使用 setter 方法设置属性值时，该属性值将被自动存储在强引用变量中，并在需要时自动释放。在使用 getter 方法获取属性值时，我们将返回一个指向该属性值的强引用。</p><p>在使用 ARC 时，您不需要手动释放对象，因为编译器会自动在适当的时候生成相应的代码来管理内存。但是，您需要注意避免循环引用，以免出现内存泄漏的问题。在上面的代码示例中，我们使用 __weak 修饰符来创建弱引用，以避免循环引用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span><span style=color:#75715e>// ViewController.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#import &lt;UIKit/UIKit.h&gt;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@interface</span> <span style=color:#a6e22e>ViewController</span> : <span style=color:#a6e22e>UIViewController</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@property</span> (<span style=color:#66d9ef>nonatomic</span>, <span style=color:#66d9ef>strong</span>) NSString <span style=color:#f92672>*</span>message;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ViewController.m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#import &#34;ViewController.h&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@implementation</span> <span style=color:#a6e22e>ViewController</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>viewDidLoad</span> {
</span></span><span style=display:flex><span>    [super viewDidLoad];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    self.message <span style=color:#f92672>=</span> <span style=color:#e6db74>@&#34;Hello, world!&#34;</span>; <span style=color:#75715e>// 使用 setter 方法设置属性值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    NSLog(<span style=color:#e6db74>@&#34;%@&#34;</span>, self.message);     <span style=color:#75715e>// 使用 getter 方法获取属性值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建对象并将其存储在强引用变量中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UIView <span style=color:#f92672>*</span>view <span style=color:#f92672>=</span> [[UIView alloc] initWithFrame:CGRectMake(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>)];
</span></span><span style=display:flex><span>    self.view <span style=color:#f92672>=</span> view;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在方法中创建对象，由于该对象未被存储在强引用变量中，因此会被释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    [self createSubview];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- (<span style=color:#66d9ef>void</span>)<span style=color:#a6e22e>createSubview</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建对象并将其存储在弱引用变量中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UIView <span style=color:#66d9ef>__weak</span> <span style=color:#f92672>*</span>weakSubview <span style=color:#f92672>=</span> [[UIView alloc] initWithFrame:CGRectMake(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>50</span>, <span style=color:#ae81ff>50</span>)];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 添加子视图，此时子视图仍然存在
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    [self.view addSubview:weakSubview];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 __weak 修饰符创建弱引用，防止循环引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ViewController <span style=color:#66d9ef>__weak</span> <span style=color:#f92672>*</span>weakSelf <span style=color:#f92672>=</span> self;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在 block 中使用 weakSelf，防止循环引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    [UIView animateWithDuration:<span style=color:#ae81ff>1.0</span> animations:<span style=color:#f92672>^</span>{
</span></span><span style=display:flex><span>        weakSelf.view.alpha <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>    }];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在方法结束时，weakSubview 对象将被释放，因为没有强引用变量引用它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>@end</span>
</span></span></code></pre></div><h2 id=swift>Swift</h2><blockquote><p><a href=https://github.com/pro648/tips/blob/master/sources/strong%E3%80%81weak%E5%92%8Cunowned%E7%9A%84%E5%8C%BA%E5%88%AB.md>strong、weak和unowned的区别</a></p></blockquote><h3 id=1-arc>1. ARC</h3><p>自动引用计数（即 Automated Reference Count，简称 ARC）是 Xcode 4.2版本的新特性，其与手动管理内存使用了相同的计数系统。不同点在于：系统在编译时会帮助我们插入合适的内存管理方法，保留和释放都会自动进行，避免了手动管理引用计数的一些潜在问题。</p><p>Swift 使用自动引用计数跟踪、管理app的内存。通常情况下，这意味着ARC会自动管理内存，开发者无需关注内存管理。当类的实例不再使用时，ARC会自动释放其占用的内存。</p><p>为帮助管理内存，ARC 有时需了解类之间的关系。在 Swift 中使用 ARC 与在 Objective-C 中使用 ARC 类似。</p><p>引用计数只适用类的实例。结构体和枚举是值类型，不是引用类型，存储和传递的时候并非使用引用。</p><h3 id=2-strong>2. strong</h3><p><code>strong</code>指针通过增加指向对象的引用计数，保护被指向对象不被ARC释放。即，只要有一个强指针指向该对象，它就不会被释放。</p><p>Swift 中声明的属性默认是<code>strong</code>。当对象间引用关系是线性时，使用<code>strong</code>指针不会产生问题。</p><p>当两个实例使用强指针指向彼此时，两个实例引用计数都不会变为零，即产生循环引用（strong reference cycle）。</p><p>下面是一个循环引用的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> name: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(name: String) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.name = name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> apartment: Apartment?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>deinit</span> {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>\(</span>name<span style=color:#e6db74>)</span><span style=color:#e6db74> is being deinitizlized&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Apartment</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> unit: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(unit: String) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.unit = unit
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> tenant: Person?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>deinit</span> {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Apartment </span><span style=color:#e6db74>\(</span>unit<span style=color:#e6db74>)</span><span style=color:#e6db74> is being deinitialized&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=3-解决循环引用>3. 解决循环引用</h3><p>Swift 提供了两种解决循环引用的方案：<code>weak</code>和<code>unowned</code>。<code>weak</code>和<code>unowned</code>引用其它实例时不会产生强引用，引用计数不会加一。因此，不会产生循环引用。</p><p>当一个实例的生命周期短于另一个时（即一个实例可以先被销毁），使用<code>weak</code>引用。在上面公寓的示例中可能出现公寓没有住户的情况。因此，可以使用<code>weak</code>解决循环引用问题。当另一个实例生命周期与当前实例相同，或长于当前实例时，使用<code>unowned</code>引用。</p></article></html>