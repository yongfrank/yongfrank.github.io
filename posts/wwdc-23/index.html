<!doctype html><html lang=en-us><title>WWDC 23 and Swift Updates | Blog by Frank</title><meta charset=utf-8><script async src="https://www.googletagmanager.com/gtag/js?id=G-XZQ6YTCMN7"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XZQ6YTCMN7",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary_large_image"><meta property="og:type" content="article"><meta property="og:title" content="WWDC 23 and Swift Updates | Blog by Frank"><meta name=twitter:title content="WWDC 23 and Swift Updates | Blog by Frank"><meta property="og:description" content="Vision Pro Simulator

Download Link


install with command line"><meta property="og:url" content="https://yongfrank.github.io/posts/wwdc-23/"><meta property="og:site_name" content="Blog by Frank"><meta name=generator content="Hugo 0.115.1"><meta name=description content="Explorations, Reflections, and More on My Blog"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://yongfrank.github.io/css/index.css><link rel=canonical href=https://yongfrank.github.io/posts/wwdc-23/><link rel=alternate type=application/rss+xml href title="Blog by Frank"><link rel=stylesheet href=https://yongfrank.github.io/katex/katex.min.css><link rel="shortcut icon" href=favicon.ico><script defer src=https://yongfrank.github.io/katex/katex.min.js></script>
<script defer src=https://yongfrank.github.io/katex/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#578490><meta name=msapplication-TileColor content="#da532c"><head><script src=/js/MathJax/es5/tex-chtml.js></script></head><header><a href=https://yongfrank.github.io/ class=title>Blog by Frank</a><nav><a href=/about/>About</a></nav></header><article><header><h1>WWDC 23 and Swift Updates</h1><time datetime=2023-06-28T13:40:53+08:00>June 28, 2023</time></header><h2 id=vision-pro-simulator>Vision Pro Simulator</h2><ul><li><a href=https://developer.apple.com/download/>Download Link</a></li></ul><blockquote><p><a href=https://developer.apple.com/documentation/xcode/installing-additional-simulator-runtimes>install with command line</a></p></blockquote><pre tabindex=0><code>xcode-select -s /Applications/Xcode-beta.app
xcodebuild -runFirstLaunch
xcrun simctl runtime add &#34;~/Downloads/watchOS 9 beta Simulator Runtime.dmg&#34;
</code></pre><h2 id=swift-macro>Swift Macro</h2><blockquote><p><a href=https://developer.apple.com/documentation/Swift/applying-macros>Applying Macros</a></p><p><a href=https://www.jianshu.com/p/5f5f7c4e1dc0>swift中的宏定义 - 2016</a></p><p><a href=https://juejin.cn/post/7244720558771159098>开始写一个 Swift 宏吧</a></p></blockquote><blockquote><p>OpenAI</p><p>在编程中，宏（Macro）是一种方式，允许你定义一段代码，然后在程序的其他地方多次使用。想象一下，你在编写一个程序，里面有一个任务需要你多次重复，而且每次重复的内容都是一样的。如果你手动写这些代码，不仅会浪费时间，而且如果要修改这段代码，你就需要在所有用到的地方都进行修改。</p><p>这就是宏的用武之地。你可以创建一个宏，定义那段需要重复的代码，然后在程序的其他地方只需要调用这个宏就可以了。这样，你就只需要写一次代码，然后在需要的地方重复使用。而且如果需要修改代码，只需修改宏的定义就可以了，而不需要在程序的每个地方都进行修改。</p><p>举个例子，如果你在编写一个游戏，并且在很多地方都需要计算玩家的分数，你可以创建一个计算分数的宏，然后在需要计算分数的地方都调用这个宏，这样就能避免重复编写相同的代码。</p><p>简单来说，宏就像是一个可以重复使用的代码片段，让你可以在多个地方使用同样的代码，而不需要重复编写。</p></blockquote><blockquote><p>宏（Macro）和函数是编程中两种常用的代码复用工具，它们都可以使程序员避免重复编写代码。然而，它们的工作方式和用途有所不同。以下是它们的主要区别：</p><ol><li><p>预处理和编译：
宏是在预处理阶段展开的。预处理器会在编译代码之前，将所有宏调用替换为相应的代码。而函数则是在编译阶段处理的，当函数被调用时，程序会跳转到函数所在的内存位置，执行函数代码，然后返回到调用处。</p></li><li><p>性能：
由于宏只是简单地替换代码，所以它们不需要函数调用的开销（例如设置堆栈帧，跳转到函数代码等），因此它们可能会比函数快。然而，过度使用宏可能会导致代码膨胀，因为每次使用宏，编译器都会生成一份新的代码。另一方面，函数只在内存中存在一份，无论调用多少次。</p></li><li><p>类型检查：
函数在编译时会进行类型检查，这可以帮助发现错误。而宏不会进行类型检查，因为它们只是文本替换，这可能会导致错误更难发现。</p></li><li><p>范围：
函数有其自己的作用域，这意味着在函数内部定义的变量在函数外部不可见。而宏没有这样的作用域，它们只是简单地替换文本。</p></li><li><p>表达能力：
函数比宏更强大，更灵活。函数可以有复杂的控制流程（如循环和条件语句），可以递归调用，可以返回值，等等。而宏的能力较为有限。</p></li></ol><p>总的来说，宏和函数都有其用途。宏通常用于定义简单的代码片段，这些片段会在代码的多个地方完全一样地使用。函数则用于定义更复杂的代码行为，特别是当代码涉及到控制流程，或者需要被反复调用但不想造成代码膨胀时。</p></blockquote><h2 id=xcode-other-linker-flags>Xcode Other Linker Flags</h2><p><a href=https://developer.apple.com/forums/thread/731089>Xcode 15 linking error</a></p><blockquote><p>Hi, I am getting a linking error when building my app to run against an iOS17 device, using Xcode15. Same project builds and runs fine with Xcode 14 and iOS16. The linking error just says:</p><p>clang: error: unable to execute command: Segmentation fault: 11 clang: error: linker command failed due to signal (use -v to see invocation)</p><p>Not sure what I should try to overcome this. I can&rsquo;t run my app on an iOS17 device. It builds, links and runs just fine on a simulator.</p><p>Working now after I added &ldquo;-ld64&rdquo; to &ldquo;Other linker Flags&rdquo;. Thank you @songme</p></blockquote><p><a href=https://zhuanlan.zhihu.com/p/34232905>iOS 温习之路 ”Other Linker Flags“</a></p><blockquote><p>话又说回来了，Other Linker Flags 到底是干什么的呢？ 从文档上对这个参数的使用也大概能猜出一二，熟悉苹果的开发者应该都知道 XCode链接器man ld命令，通俗点讲，连接器的目的就是将目标文件连接为可执行程序，详细了解请阅读<a href=https://zhuanlan.zhihu.com/p/31895059>源程序->可执行程序</a></p></blockquote><p><a href=https://zhuanlan.zhihu.com/p/31895059>源程序->可执行程序 - 小萝卜的文章 - 知乎</a></p><blockquote><p>.c（源程序）->.obj（目标文件）的过程我们称之为编译，.obj（目标文件）->.exe（可执行文件）的过程我们称之为链接。</p></blockquote><p><img src=https://pic1.zhimg.com/80/v2-f996490e3e745d2d91fcd01e28332074_1440w.webp alt="源程序->可执行文件"></p><p><a href=https://segmentfault.com/a/1190000040726418>深入 iOS 静态链接器（一）— ld64</a></p><p><img src=https://segmentfault.com/img/remote/1460000040726420 alt="静态链接（static linking）"></p></article></html>