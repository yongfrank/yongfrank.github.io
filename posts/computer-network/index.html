<!doctype html><html lang=en-us><title>Computer Network | Blog by Frank</title><meta charset=utf-8><script async src="https://www.googletagmanager.com/gtag/js?id=G-XZQ6YTCMN7"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XZQ6YTCMN7")}</script><meta name=twitter:card content="summary_large_image"><meta property="og:type" content="article"><meta property="og:title" content="Computer Network | Blog by Frank"><meta name=twitter:title content="Computer Network | Blog by Frank"><meta property="og:description" content="Layer
"><meta property="og:url" content="https://yongfrank.github.io/posts/computer-network/"><meta property="og:site_name" content="Blog by Frank"><meta name=generator content="Hugo 0.150.1"><meta name=description content="Explorations, Reflections, and More on My Blog"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://yongfrank.github.io/css/index.css><link rel=canonical href=https://yongfrank.github.io/posts/computer-network/><link rel=alternate type=application/rss+xml href title="Blog by Frank"><link rel=stylesheet href=https://yongfrank.github.io/katex/katex.min.css><link rel="shortcut icon" href=favicon.ico><script defer src=https://yongfrank.github.io/katex/katex.min.js></script><script defer src=https://yongfrank.github.io/katex/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#578490><meta name=msapplication-TileColor content="#da532c"><head><script src=/js/MathJax/es5/tex-chtml.js></script></head><header><a href=https://yongfrank.github.io/ class=title>Blog by Frank</a><nav><a href=/about/>About</a></nav></header><article><header><h1>Computer Network</h1><time datetime=2023-07-21T09:13:51+08:00>July 21, 2023</time></header><h2 id=layer>Layer</h2><p><img src=https://miro.medium.com/v2/resize:fit:1044/format:webp/0*f_JZX-PtepdZwOlN.png alt="Network layer model"></p><h3 id=application-layer>Application Layer</h3><p>BGP DHCP(v6) DNS FTP HTTP HTTPS IMAP IRC LDAP MGCP MQTT NNTP NTP OSPF POP PTP ONC/RPC RTP RTSP RIP SIP SMTP SNMP SSH Telnet TLS/SSL(HTTPS)</p><h3 id=presentation-layer>Presentation Layer</h3><p>MIME</p><h3 id=session-layer>Session Layer</h3><p>PPTP</p><h3 id=transport-layer>Transport Layer</h3><p>TCP: (Three way handshake, four way handshake) UDP DCCP SCTP RSVP QUIC</p><h3 id=network-layer>Network Layer</h3><p>IP IPv4 IPv6 ICMP ICMPv6 ECN IGMP OSPF IPsec RIP</p><h3 id=data-link-layer>Data Link Layer</h3><p>Tunnels PPP MAC</p><h3 id=physical-layer>Physical Layer</h3><p>IEEE 802.11(a, b, g, n, ac, ax)</p><h2 id=ca-https-symmetric-key-algorithm-public-key-cryptography-application-layer>CA, Https, Symmetric-key algorithm, Public-key cryptography (Application Layer)</h2><ul><li><a href=https://www.bilibili.com/video/BV1TP411G7wb>非对称加密、对称加密、签名、CA机构、证书、https - bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1zb4y127JU/?share_source=copy_web&amp;vd_source=bf4952280cde801b178268abc99a7047">HTTP是什么？- bilibili</a></li></ul><h3 id=public-key-cryptography>Public-key cryptography</h3><p>Public Key - Public Key Encryption</p><p>Private Key - Private Key Decryption</p><p>Certificate Authority (CA) Sign on the public key with its private key</p><h3 id=tls-over-tcp>TLS over TCP</h3><p><a href=https://www.bilibili.com/video/BV1KY411x7Jp>加密原理和证书。SSL/TLS握手过程</a></p><p>在传统的TCP三次握手过程中，不涉及TLS（Transport Layer Security）加密。三次握手是建立TCP连接的过程，用于在客户端和服务器之间建立可靠的数据传输通道。</p><p>然而，如果在TCP连接建立后，应用程序需要进行安全的数据传输，就可以在TCP连接的基础上使用TLS来实现加密。TLS是一种加密协议，用于在网络通信中保护数据的安全性和完整性。</p><p>在TLS加密流程中，大致可以分为以下几个步骤：</p><ul><li>客户端发送ClientHello：客户端向服务器发送ClientHello消息，包含了支持的加密套件列表和随机数等信息。</li><li>服务器发送ServerHello：服务器从客户端发送的加密套件列表中选择一个加密套件，并向客户端发送ServerHello消息，包含了服务器选择的加密套件和随机数等信息。</li><li>客户端和服务器交换密钥：客户端根据服务器发送的信息生成会话密钥，并将其加密后发送给服务器。服务器接收到客户端发送的密钥后，使用私钥解密得到会话密钥。</li><li>加密数据传输：建立了安全的会话密钥后，客户端和服务器之间的数据传输都会使用该密钥进行加密和解密，确保数据在传输过程中的安全性。</li><li>完成握手：最后，客户端和服务器交换Finished消息，以确认握手过程完成，双方可以开始进行加密数据传输。</li></ul><p>值得注意的是，TLS加密过程发生在TCP连接建立完成后。因此，在TCP三次握手阶段，还没有进行TLS加密。TLS加密是在建立了可靠的TCP连接后进行的，用于保障后续数据传输的安全。</p><h2 id=tcp-three-way-handshake-four-way-handshake-termination-transport-layer>TCP Three-way handshake, four-way handshake Termination (Transport Layer)</h2><p><a href="https://www.bilibili.com/video/BV18h41187Ep/?share_source=copy_web&amp;vd_source=bf4952280cde801b178268abc99a7047">bilibili - TCP三次握手和四次挥手</a></p><pre tabindex=0><code>Client SYN 8633
Server SYN 303 ACK 8634
Server 8634 ACK 304

Client FIN ACK
Server ACK
Server FIN ACK
Client ACK
</code></pre><p>三次握手和四次挥手是TCP协议中建立和断开连接的过程。</p><p>三次握手（Three-Way Handshake）：</p><p>客户端发送连接请求（SYN：Synchronize）给服务器，表示客户端要建立连接。
服务器收到连接请求后，回复一个确认连接请求（SYN-ACK：Synchronize-Acknowledge）给客户端。
客户端收到服务器的确认连接请求后，再回复一个确认连接请求（ACK：Acknowledge）给服务器。
这样，建立连接的过程就完成了，双方都确认对方能够收发数据，可以开始传输数据。</p><p>四次挥手（Four-Way Handshake）：</p><p>客户端发送断开连接请求（FIN：Finish）给服务器，表示客户端要断开连接。
服务器收到断开连接请求后，回复一个确认断开连接请求（ACK）给客户端，表示服务器已经收到了断开请求。
服务器检查是否还有未传输完的数据，如果有，先传输完数据再发送一个断开连接请求（FIN）给客户端，表示服务器也准备好断开连接了。
客户端收到服务器的断开连接请求后，回复一个确认断开连接请求（ACK）给服务器，表示客户端已经收到了断开请求。
这样，断开连接的过程就完成了，双方都确认对方已经断开连接，不再传输数据。</p><p>总结：</p><p>三次握手用于建立连接，确保双方都能正常通信。
四次挥手用于断开连接，确保双方都知道对方已经断开连接，不再传输数据。</p></article></html>